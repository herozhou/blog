<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Node Buffer源码分析 - herozhou工巧</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="herozhou工巧" />
  <meta name="description" content="这篇文章主要讲了 Node 中 buffer 加载的原理。

" />

  <meta name="keywords" content="herozhou, herozhou工巧, 工巧" />






<meta name="generator" content="Hugo 0.31.1" />


<link rel="canonical" href="http://blog.herozhou.com/post/node-buffer/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=2.7.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">

<meta property="og:title" content="Node Buffer源码分析" />
<meta property="og:description" content="这篇文章主要讲了 Node 中 buffer 加载的原理。

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://blog.herozhou.com/post/node-buffer/" />



<meta property="article:published_time" content="2017-10-10T16:01:23&#43;08:00"/>

<meta property="article:modified_time" content="2017-10-11T16:01:23&#43;08:00"/>











<meta itemprop="name" content="Node Buffer源码分析">
<meta itemprop="description" content="这篇文章主要讲了 Node 中 buffer 加载的原理。

">


<meta itemprop="datePublished" content="2017-10-10T16:01:23&#43;08:00" />
<meta itemprop="dateModified" content="2017-10-10T16:01:23&#43;08:00" />
<meta itemprop="wordCount" content="2716">



<meta itemprop="keywords" content="Node.js," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Node Buffer源码分析"/>
<meta name="twitter:description" content="这篇文章主要讲了 Node 中 buffer 加载的原理。

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">herozhou工巧</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">herozhou工巧</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Node Buffer源码分析</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-10-10 </span>
        <div class="post-category">
            
              <a href="/categories/node.js%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"> Node.js源码分析 </a>
            
          </div>
        <span class="more-meta"> 约 2716 字 </span>
        <span class="more-meta"> 预计阅读 6 分钟 </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#buffer">Buffer</a>
<ul>
<li><a href="#buffer-alloc">Buffer.alloc()</a></li>
<li><a href="#buffer-from">Buffer.from()`</a></li>
</ul></li>
<li><a href="#总结">总结</a></li>
<li><a href="#精选面试题">精选面试题</a></li>
<li><a href="#参考">参考</a></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>这篇文章主要讲了 Node 中 buffer 加载的原理。</p>

<p></p>

<h1 id="buffer">Buffer</h1>

<p>在 Node.js v6 之前的版本中，<code>Buffer</code> 实例是通过 <code>Buffer</code> 构造函数创建的，它根据提供的参数返回不同的 <code>Buffer</code>：</p>

<ul>
<li>传一个数值作为第一个参数给 <code>Buffer()</code>（如 <code>new Buffer(10)</code>），则分配一个指定大小的新建的 <code>Buffer</code> 对象。 在 <code>Node.js 8.0.0</code> 之前，分配给这种 <code>Buffer</code> 实例的内存是没有初始化的，且可能包含敏感数据。 这种 <code>Buffer</code> 实例随后必须被初始化，可以使用 <code>buf.fill(0)</code> 或写满这个 <code>Buffer</code>。 虽然这种行为是为了提高性能而有意为之的，但开发经验表明，创建一个快速但未初始化的 <code>Buffer</code> 与创建一个慢点但更安全的 <code>Buffer</code> 之间需要有更明确的区分。从 <code>Node.js 8.0.0</code> 开始， <code>Buffer(num)</code> 和 <code>new Buffer(num)</code> 将返回一个初始化内存之后的 Buffer。</li>
<li>传一个字符串、数组、或 <code>Buffer</code> 作为第一个参数，则将所传对象的数据拷贝到 <code>Buffer</code> 中。</li>
<li>传入一个 <code>ArrayBuffer</code>，则返回一个与给定的 <code>ArrayBuffer</code> 共享所分配内存的 Buffer。
因为 <code>new Buffer()</code> 的行为会根据所传入的第一个参数的值的数据类型而明显地改变，所以如果应用程序没有正确地校验传给 <code>new Buffer()</code> 的参数、或未能正确地初始化新分配的 <code>Buffer</code> 的内容，就有可能在无意中为他们的代码引入安全性与可靠性问题。</li>
</ul>

<p>为了使 <code>Buffer</code> 实例的创建更可靠、更不容易出错，各种 <code>new Buffer()</code> 构造函数已被 废弃，并由 <code>Buffer.from()</code>、<code>Buffer.alloc()</code>、和 <code>Buffer.allocUnsafe()</code> 方法替代。</p>

<h2 id="buffer-alloc">Buffer.alloc()</h2>

<pre><code class="language-javascript">// lib/buffer.js
function Buffer(arg, encodingOrOffset, length) {
  doFlaggedDeprecation();
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      );
    }
    return Buffer.alloc(arg);
  }
  return Buffer.from(arg, encodingOrOffset, length);
}
</code></pre>

<p>如果传入的第一个数是数字：
则调用 <code>Buffer.alloc(arg)</code> 创建一个新的 <code>Buffer</code> 实例</p>

<pre><code class="language-javascript">// lib/buffer.js

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function(size, fill, encoding) {
  assertSize(size);
  if (size &gt; 0 &amp;&amp; fill !== undefined) {
    // Since we are filling anyway, don't zero fill initially.
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    if (typeof encoding !== 'string')
      encoding = undefined;
    return createUnsafeBuffer(size).fill(fill, encoding);
  }
  return new FastBuffer(size);
};

// FastBuffer
class FastBuffer extends Uint8Array {
  constructor(arg1, arg2, arg3) {
    super(arg1, arg2, arg3);
  }
}
FastBuffer.prototype.constructor = Buffer;

Buffer.prototype = FastBuffer.prototype;


// createUnsafeBuffer
function createUnsafeBuffer(size) {
  return new FastBuffer(createUnsafeArrayBuffer(size));
}

function createUnsafeArrayBuffer(size) {
  zeroFill[0] = 0;
  try {
    return new ArrayBuffer(size);
  } finally {
    zeroFill[0] = 1;
  }
}
</code></pre>

<ul>
<li>如果参数&gt; 0 并且没有指定默认填充数值，则使用 <code>FastBuffer</code> 创建一个空的基于 <code>Uint8Array</code> 数组即一个8位无符号整型数组，创建时内容被初始化为0。</li>
<li>如果参数不为 0 ，则使用 <code>ArrayBuffer</code> 开辟一个以 <code>size</code> 为固定长度的二进制数据缓冲区。我们不能直接操纵 <code>ArrayBuffer</code> 的内容，而应该创建一个表示特定格式的buffer的类型化数组对象( <code>typed array objects</code> )或数据视图对象 <code>DataView</code> 来对buffer的内容进行读取和写入操作。这里 Node 将它转化为 <code>FastBuffer</code> 从而使用 <code>Uint8Array</code> 来操作它。</li>
</ul>

<p>由此来看，正好对应了文档中那句话：<code>Buffer</code> 实例也是 <code>Uint8Array</code> 实例</p>

<p><code>ArrayBuffer对象</code>、<code>TypedArray</code> 对象以及 <code>DataView</code> 对象在ES6的时候纳入了 <code>ECMAScript</code> 规范里面
* <code>ArrayBuffer</code>:内存中一段原始的二进制数据，可以通过“视图”进行操作。
* <code>Uint8Array</code> :数组类型表示一个8位无符号整型数组，创建时内容被初始化为0。创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素
* <code>TypedArray</code> :描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图
* <code>Uint8Array</code> :是 <code>TypedArray</code> 的一个实现。</p>

<p>简单点而言， <strong>就是Buffer模块使用v8::ArrayBuffer分配一片内存，通过TypedArray中的v8::Uint8Array来去写数据</strong></p>

<h2 id="buffer-from">Buffer.from()`</h2>

<p>而如果传入的第一个参数不是数字：</p>

<pre><code class="language-javascript">
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function(value, encodingOrOffset, length) {

  if (typeof value === 'string')
    return fromString(value, encodingOrOffset);

  if (isAnyArrayBuffer(value))
    return fromArrayBuffer(value, encodingOrOffset, length);

  if (value === null || value === undefined)
    throw new TypeError(kFromErrorMsg);

  if (typeof value === 'number')
    throw new TypeError('&quot;value&quot; argument must not be a number');

  const valueOf = value.valueOf &amp;&amp; value.valueOf();
  if (valueOf !== null &amp;&amp; valueOf !== undefined &amp;&amp; valueOf !== value)
    return Buffer.from(valueOf, encodingOrOffset, length);

  var b = fromObject(value);
  if (b)
    return b;

  if (typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'),
                       encodingOrOffset,
                       length);
  }

  throw new TypeError(kFromErrorMsg);
};

</code></pre>

<ul>
<li>如果第一个参数是 string 则新建一个包含所给的 JavaScript 字符串 string 的 Buffer 。 encoding 参数指定 string 的字符编码</li>
<li>如果第一个参数是 ArrayBuffer 类型的，则将创建一个 ArrayBuffer 的视图，而不会复制底层内存。例如，当传入一个 TypedArray 实例的 .buffer 属性的引用时，这个新建的 Buffer 会像 TypedArray 那样共享同一分配的内存。可选的 byteOffset 和 length 参数指定将与 Buffer 共享的 arrayBuffer 的内存范围</li>
<li>如果第一个参数对于其valueOf（）函数返回的值不完全等于自身的对象，则调用Buffer.from将该参数的实际数值转化为 Buffer 。
例如
<code>javascript
const buf = Buffer.from(new String('this is a test'));
// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt;
</code></li>
<li>如果第一个参数支持 <code>Symbol.toPrimitive</code> ，则调用Buffer.from将该参数转化为 Buffer
```javascript
class Foo {
[Symbol.toPrimitive]() {
return &lsquo;this is a test&rsquo;;
}
}</li>
</ul>

<p>const buf = Buffer.from(new Foo(), &lsquo;utf8&rsquo;);
// <Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74></p>

<pre><code>
## Buffer.allocUnsafe()
看过了```Buffer.from()```、```Buffer.alloc()```、接下来看看 ```Buffer.allocUnsafe()``` 方法
分配一个大小为 size 字节的新建的 Buffer 。 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 RangeError 错误。 如果 size 为 0，则创建一个长度为 0 的 Buffer。

以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据，可能携带该缓存区之前的数据，如果缓存里面的内容是一些私钥、密码等敏感信息的话就可有可能被泄漏出去。 可以使用 buf.fill(0) 初始化 Buffer 实例为0。
```javascript

Buffer.allocUnsafe = function(size) {
  assertSize(size);
  return allocate(size);
};

Buffer.poolSize = 8 * 1024;

function allocate(size) {
  if (size &lt;= 0) {
    return new FastBuffer();
  }
  if (size &lt; (Buffer.poolSize &gt;&gt;&gt; 1)) {
    if (size &gt; (poolSize - poolOffset))
      createPool();
    var b = new FastBuffer(allocPool, poolOffset, size);
    poolOffset += size;
    alignPool();
    return b;
  } else {
    return createUnsafeBuffer(size);
  }
}


function createPool() {
  poolSize = Buffer.poolSize;
  allocPool = createUnsafeArrayBuffer(poolSize);
  poolOffset = 0;
}
</code></pre>

<p>注意，<code>Buffer</code> 模块会预分配一个大小为 <code>Buffer.poolSize</code> 的内部 <code>Buffer</code> 实例作为快速分配池， 用于使用 <code>Buffer.allocUnsafe()</code> 新创建的 <code>Buffer</code> 实例，以及废弃的 <code>new Buffer(size)</code> 构造器， 仅限于当 <code>size</code> 小于或等于 <code>Buffer.poolSize &gt;&gt; 1</code> （Buffer.poolSize 除以2后的最大整数值）。</p>

<p>对这个预分配的内部内存池的使用，是调用 <code>Buffer.alloc(size, fill)</code> 和 <code>Buffer.allocUnsafe(size).fill(fill)</code> 的关键区别。 具体地说，如果 <code>size</code> 小于或等于 <code>Buffer.poolSize</code> 的一半，则 <code>Buffer.alloc(size, fill)</code> 不会使用这个内部的 <code>Buffer</code> 池，而 <code>Buffer.allocUnsafe(size).fill(fill)</code> 会使用这个内部的 <code>Buffer</code> 池。 当应用程序需要 <code>Buffer.allocUnsafe()</code> 提供额外的性能时，这个细微的区别是非常重要的。</p>

<p><img src="https://segmentfault.com/img/bVLoJS?w=664&amp;h=446" alt="image" />
如上图，如果当前存储了2KB的数据，后面要存储5KB大小数据的时候分配池判断所需内存空间大于4KB，则会去重新申请内存空间来存储5KB数据并且分配池的当前偏移指针也是指向新申请的内存空间，这时候就之前剩余的6KB(8KB-2KB)内存空间就会被搁置。</p>

<p>回头想一下 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 RangeError 错误 这句话
小于 0 抛出错误很正常，那么大于 buffer.constants.MAX_LENGTH 呢？这个数值代表着什么？
这个数值也就是kMaxLength —— 分配给单个 Buffer 实例的最大内存，定义在src/node_buffer.h中</p>

<pre><code class="language-c">static const unsigned int kMaxLength =
    sizeof(int32_t) == sizeof(intptr_t) ? 0x3fffffff : 0x7fffffff;
</code></pre>

<p>在32位体系结构上，这个值是(2^30)-1 (~1GB)。 在64位体系结构上，这个值是(2^31)-1 (~2GB)。</p>

<h1 id="总结">总结</h1>

<ul>
<li>new Buffer(): 依赖 Buffer.from() 和 Buffer.alloc()</li>
<li>Buffer.from()</li>
<li>* ArrayBuffer: 直接使用 ArrayBuffer 创建 FastBuffer</li>
<li>* String: 小于 4k 使用8k池，大于 4k 调用 binding.createFromString()</li>
<li>* Object: 小于 4k 使用8k池，大于 4k 调用 createUnsafeBuffer()</li>
<li>Buffer.alloc(): 需要 fill buffer，用给定字符填充，否则用 0 填充</li>
<li>Buffer.allocUnsafe(): 小于 4k 使用8k池，大于 4k 调用 createUnsafeBuffer()</li>
<li>Buffer.allocUnsafeSlow(): 调用 createUnsafeBuffer()</li>
</ul>

<h1 id="精选面试题">精选面试题</h1>

<pre><code>let arr = [];
while(true)
  arr.push(new Buffer(1000));
</code></pre>

<p>会不会将内存爆掉？
答： buffer不走v8的local handle分配和释放，也就不属于v8的堆内内存部分，所以没有1.4g的限制，当然爆掉还是会的。可能会将内存爆掉，当主机的内存全部被node占满之后。</p>

<p>需要将一个足足有3.3GB的JSON ARRAY导入到我的项目中，然后并发的对数组内的元素进行处理</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="http://nodejs.cn/api/buffer.html#buffer_buffer">http://nodejs.cn/api/buffer.html#buffer_buffer</a></li>
<li><a href="https://segmentfault.com/a/1190000008877009">https://segmentfault.com/a/1190000008877009</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array</a></li>
</ul>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">herozhou工巧</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2017-10-11</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/node.js/">Node.js</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/english-preview/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">自底向上 —— 事件循环的原理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/node-builtin/">
            <span class="next-text nav-default">Node builtin模块加载源码分析</span>
            <span class="prev-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'blog-herozhou';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:herozhou97@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://blog.herozhou.com/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">herozhou工巧</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=2.7.0"></script>


<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-111510751-1', 'auto');
ga('send', 'pageview');
</script>
<script async src='//www.google-analytics.com/analytics.js'></script>



</body>
</html>
